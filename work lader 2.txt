/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return [];
    
    const parents = new Map(); // word -> list of previous words
    const level = new Set([beginWord]);
    const visited = new Set();
    let found = false;
    
    while (level.size && !found) {
        const nextLevel = new Set();
        
        // mark visited for this level
        for (let word of level) {
            visited.add(word);
        }
        
        for (let word of level) {
            const wordArr = word.split('');
            
            for (let i = 0; i < wordArr.length; i++) {
                const originalChar = wordArr[i];
                
                for (let c = 97; c <= 122; c++) {
                    const char = String.fromCharCode(c);
                    if (char === originalChar) continue;
                    
                    wordArr[i] = char;
                    const newWord = wordArr.join('');
                    
                    if (wordSet.has(newWord) && !visited.has(newWord)) {
                        
                        if (newWord === endWord) found = true;
                        
                        if (!parents.has(newWord)) {
                            parents.set(newWord, []);
                        }
                        parents.get(newWord).push(word);
                        
                        nextLevel.add(newWord);
                    }
                }
                
                wordArr[i] = originalChar;
            }
        }
        
        level.clear();
        for (let word of nextLevel) {
            level.add(word);
        }
    }
    
    const result = [];
    
    if (!found) return result;
    
    // Backtracking
    const backtrack = (word, path) => {
        if (word === beginWord) {
            result.push([beginWord, ...path]);
            return;
        }
        
        for (let parent of parents.get(word) || []) {
            backtrack(parent, [word, ...path]);
        }
    };
    
    backtrack(endWord, []);
    
    return result;
};